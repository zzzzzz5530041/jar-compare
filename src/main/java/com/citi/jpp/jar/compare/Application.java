package com.citi.jpp.jar.compare;

import lombok.extern.slf4j.Slf4j;
import org.objectweb.asm.ClassReader;

import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
public class Application {
    public static void main(String[] args) throws Exception {
        List<MethodRef > addedMethods = new ArrayList<>();
        List<MethodRef > deletedMethods = new ArrayList<>();
        List<MethodRef > modifiedMethods = new ArrayList<>();
        String oldJar = "C:\\Users\\Administrator\\.m2\\repository\\org\\apache\\xmlbeans\\xmlbeans\\3.1.0\\xmlbeans-3.1.0.jar";
        String newJar = "C:\\Users\\Administrator\\.m2\\repository\\org\\apache\\xmlbeans\\xmlbeans\\5.1.1\\xmlbeans-5.1.1.jar";
        List<ClassFileEntity> newClassEntities = new ArrayList<>(ClassFileUtils.getClassesFromJars("new", newJar));
        Holder newJarHolder = go(ClassFileUtils.getClassesFromJars("new", newJar));
        Holder oldJarHolder = go(ClassFileUtils.getClassesFromJars("old", oldJar));
        // compare class
        List<String> newClassNames = newJarHolder.classFileList.stream().map(ClassFileEntity::getClassName).collect(Collectors.toList());
        List<String> oldClassNames = oldJarHolder.classFileList.stream().map(ClassFileEntity::getClassName).collect(Collectors.toList());
        // get added classes
        List<String> addClassNames = newClassNames.stream().filter(c -> !oldClassNames.contains(c)).collect(Collectors.toList()); // generated by AI
        // get deleted classes
        List<String> delClassNames = oldClassNames.stream().filter(c -> !newClassNames.contains(c)).collect(Collectors.toList());// generated by AI
        // get modified classes, will compare the methods and members of these classes
        List<String> modifyClassNames = newClassNames.stream().filter(c -> oldClassNames.contains(c)).collect(Collectors.toList());// generated by AI
        System.out.println("addClassNames=" + addClassNames);
        System.out.println("--------------------------------");
        System.out.println("--------------------------------");
        System.out.println("--------------------------------");
        System.out.println("--------------------------------");
        System.out.println("--------------------------------");
        System.out.println("delClassNames" + delClassNames);

        // compare method
        Map<MethodRef.Handle, MethodRef> newClassMethodsMap = newJarHolder.methodMap;
        Map<MethodRef.Handle, MethodRef> oldClassMethodsMap = oldJarHolder.methodMap;
        // find added methods and modified methods
        for (Map.Entry<MethodRef.Handle, MethodRef> entry : newClassMethodsMap.entrySet()) {// generated by AI
            MethodRef.Handle handle = entry.getKey(); // get class name
            MethodRef newMethodRef = entry.getValue(); // get
            MethodRef oldMethodRef = oldClassMethodsMap.get(handle);
            if (oldMethodRef == null) {
                if (addClassNames.contains(handle.getClassReference().getName() + ".class")) {
//                    System.out.println(" new method in new class : "+newMethodRef);
                } else {
                    System.out.println(" added method : " + newMethodRef);
                    addedMethods.add(newMethodRef);
                }
            } else {
                if (!newMethodRef.equals(oldMethodRef)) {
                    System.out.println("modify method " + newMethodRef + "####" + oldMethodRef);
                    modifiedMethods.add(oldMethodRef);
                } else {
                    // this un-modified method. at least ,method name,signature,access is not change
//                    System.out.println("un-modified method "+newMethodRef +"###"+oldMethodRef);
                }
            }
        }
        // find deleted methods
        for (Map.Entry<MethodRef.Handle, MethodRef> entry : oldClassMethodsMap.entrySet()) {
            MethodRef.Handle handle = entry.getKey(); // get class name
            MethodRef oldMethodRef = entry.getValue(); // get
            MethodRef newMethodRef = newClassMethodsMap.get(handle);
            if (newMethodRef == null) {
                if (delClassNames.contains(handle.getClassReference().getName() + ".class")) {
//                    System.out.println(" new method in new class : "+newMethodRef);
                } else {
                    System.out.println(" deleted method : " + oldMethodRef);
                    deletedMethods.add(oldMethodRef);
                }
            } else {
                if (!newMethodRef.equals(oldMethodRef)) {
                    // already printed
//                    System.out.println("------modify method " + newMethodRef + "####" + oldMethodRef);
                } else {
                    // this un-modified method. at least ,method name,signature,access is not change

                }
            }
        }







    }

    private static Holder go(Set<ClassFileEntity> classFileList) {
        Holder holder = new Holder();
        for (ClassFileEntity file : classFileList) {
            MyClassVisitor classVisitor = new MyClassVisitor(holder.classRefs, holder.methodRefs, file.getJarName());
            ClassReader cr = new ClassReader(getFileByte(file));
            cr.accept(classVisitor, ClassReader.EXPAND_FRAMES);
        }
        holder.classRefs.forEach(c -> {
            holder.classMap.put(c.getHandle(), c);
        });
        holder.methodRefs.forEach(m -> {
            holder.methodMap.put(m.getHandle(), m);
        });
        log.info("classMap {}", holder.classMap);
        log.info("methodMap {}", holder.methodMap);
        holder.classMap = holder.classMap;
        holder.methodMap = holder.methodMap;
        holder.classFileList = classFileList;
        return holder;
    }

    public static byte[] getFileByte(ClassFileEntity file) {
        try {
            return Files.readAllBytes(file.getPath());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
